#include "main.h"
#include <stdio.h>
#include "ff.h"  // FatFs library for SD card

// ADC, UART, SPI handles (ensure they're declared in CubeMX)
ADC_HandleTypeDef hadc1;
UART_HandleTypeDef huart2;
SPI_HandleTypeDef hspi1; // SPI handle for SD card

// SD card file system object
FATFS fs;     // FatFs work area
FIL file;     // File object
FRESULT res;  // FatFs result code

// GPIO handle for vibration motor (example: PWM or digital output)
GPIO_InitTypeDef motorGPIO;

// Define posture thresholds (example values)
#define STANDING_THRESHOLD 1000 // Example ADC value for upright posture
#define LEANING_THRESHOLD 2000  // Example ADC value for leaning forward

// Redirect printf to UART
int __io_putchar(int ch) {
    HAL_UART_Transmit(&huart2, (uint8_t *)&ch, 1, HAL_MAX_DELAY);
    return ch;
}

// Function to calculate FSR resistance (pressure sensor)
float calculateResistance(uint32_t adcValue, float vRef, float rFixed) {
    float vOut = (adcValue / 4095.0) * vRef; // Convert ADC value to voltage
    if (vOut == 0) return 1e6;              // Handle edge case for 0V
    return rFixed * ((vRef / vOut) - 1);    // Voltage divider formula
}

// Function to detect incorrect posture based on ADC value
int detectPosture(uint32_t adcValue) {
    if (adcValue > LEANING_THRESHOLD) {
        return 1; // Indicates incorrect posture (leaning forward)
    } else if (adcValue < STANDING_THRESHOLD) {
        return 1; // Indicates incorrect posture (head bent or hunched)
    }
    return 0; // Posture is correct
}

// Initialize vibration motor
void motorInit(void) {
    // Example GPIO setup for motor control (using PWM or simple digital output)
    motorGPIO.Pin = GPIO_PIN_5; // Assuming motor is connected to Pin 5
    motorGPIO.Mode = GPIO_MODE_OUTPUT_PP;
    motorGPIO.Pull = GPIO_NOPULL;
    motorGPIO.Speed = GPIO_SPEED_FREQ_LOW;
    HAL_GPIO_Init(GPIOB, &motorGPIO);  // Example: motor connected to GPIOB pin 5
}

// Trigger vibration motor for feedback
void triggerVibration(void) {
    HAL_GPIO_WritePin(GPIOB, GPIO_PIN_5, GPIO_PIN_SET);  // Turn on motor
    HAL_Delay(500);  // Vibration duration (500 ms)
    HAL_GPIO_WritePin(GPIOB, GPIO_PIN_5, GPIO_PIN_RESET); // Turn off motor
}

void SDCard_Init(void) {
    // Mount the SD card
    res = f_mount(&fs, "", 0);  // Mount the file system
    if (res != FR_OK) {
        printf("SD card mount failed: %d\n", res);
        return;
    }

    // Open the log file (create if not exists)
    res = f_open(&file, "log.txt", FA_OPEN_ALWAYS | FA_WRITE);
    if (res != FR_OK) {
        printf("File open failed: %d\n", res);
        return;
    }

    // Move the file pointer to the end (append mode)
    f_lseek(&file, f_size(&file));
}

void SDCard_WriteData(const char *data) {
    UINT bytesWritten;
    res = f_write(&file, data, strlen(data), &bytesWritten);
    if (res != FR_OK) {
        printf("Write failed: %d\n", res);
    }
}

int main(void) {
    HAL_Init();
    SystemClock_Config();
    MX_GPIO_Init();
    MX_ADC1_Init();
    MX_USART2_UART_Init(); // Add UART initialization
    MX_SPI1_Init(); // SPI initialization for SD card

    // Initialize vibration motor
    motorInit();

    // Initialize SD card for logging
    SDCard_Init();

    HAL_ADC_Start(&hadc1); // Start ADC in continuous mode

    uint32_t lastPostureCheckTime = HAL_GetTick();
    uint32_t adcValue = 0;
    int postureDetected = 0;

    while (1) {
        // Fetch the latest ADC value
        adcValue = HAL_ADC_GetValue(&hadc1);

        // Detect posture based on ADC value
        postureDetected = detectPosture(adcValue);

        if (postureDetected) {
            // Trigger vibration motor if posture is incorrect
            triggerVibration();
            // Log posture alert
            char logData[100];
            snprintf(logData, sizeof(logData), "Incorrect posture detected! ADC Value: %lu\n", adcValue);
            SDCard_WriteData(logData);
        }

        // Log posture data (even if posture is correct) to track posture over time
        char logData[100];
        snprintf(logData, sizeof(logData), "Posture Data - ADC Value: %lu\n", adcValue);
        SDCard_WriteData(logData);

        // Check for latency requirement (1 second max)
        uint32_t currentTime = HAL_GetTick();
        if ((currentTime - lastPostureCheckTime) >= 1000) {
            lastPostureCheckTime = currentTime;
        }

        HAL_Delay(33); // Wait ~1/30 seconds (30 Hz update rate)
    }
}
